<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prompt Quest ‚Äì Resilience & Pre-Flight Plan</title>
<link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Geist+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<style>
:root{--bg:#05060a;--s1:#0c0e17;--s2:#121521;--s3:#191d2d;--border:#252a40;--text:#dde0f0;--dim:#6b7199;--gold:#f5c542;--mint:#3ee8b5;--coral:#ff5a7e;--sky:#4da8ff;--violet:#9b7aff;--peach:#ffab6b;--lime:#a8e034;--hot:#ff3366;}
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Outfit',sans-serif;background:var(--bg);color:var(--text);line-height:1.72;-webkit-font-smoothing:antialiased;}
.hero{position:relative;padding:3rem 2rem 2rem;text-align:center;border-bottom:1px solid var(--border);overflow:hidden;}
.hero::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse 500px 350px at 30% 50%,rgba(255,90,126,.06),transparent),radial-gradient(ellipse 400px 300px at 70% 40%,rgba(245,197,66,.05),transparent);pointer-events:none;}
.hero-tag{font-size:.58rem;font-weight:700;text-transform:uppercase;letter-spacing:.2em;color:var(--coral);display:block;margin-bottom:.4rem;}
.hero h1{font-family:'Instrument Serif',serif;font-size:2.2rem;font-weight:400;letter-spacing:-.02em;background:linear-gradient(135deg,var(--coral),var(--gold));-webkit-background-clip:text;-webkit-text-fill-color:transparent;}
.hero-sub{color:var(--dim);font-size:.82rem;max-width:680px;margin:.5rem auto 0;}
.content{max-width:1080px;margin:0 auto;padding:2rem;}
.section{margin:2.5rem 0;}
.section-tag{font-size:.54rem;font-weight:700;text-transform:uppercase;letter-spacing:.18em;color:var(--mint);margin-bottom:.15rem;display:block;}
.section h2{font-family:'Instrument Serif',serif;font-size:1.45rem;font-weight:400;margin-bottom:.6rem;padding-bottom:.4rem;border-bottom:1px solid var(--border);}
.section h3{font-size:.86rem;font-weight:700;margin:1.2rem 0 .4rem;color:var(--gold);}
.section h4{font-size:.76rem;font-weight:600;margin:1rem 0 .3rem;color:var(--sky);}
p,li{font-size:.82rem;margin-bottom:.4rem;}
.card{background:var(--s1);border:1px solid var(--border);border-radius:10px;padding:1rem 1.2rem;margin:.6rem 0;}
.card-title{font-size:.76rem;font-weight:700;margin-bottom:.35rem;}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:.6rem;}
.grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:.6rem;}
table{width:100%;border-collapse:collapse;margin:.75rem 0;font-size:.74rem;}
th{background:var(--s2);text-align:left;padding:.5rem .65rem;font-weight:600;font-size:.58rem;text-transform:uppercase;letter-spacing:.06em;color:var(--dim);border-bottom:2px solid var(--border);}
td{padding:.45rem .65rem;border-bottom:1px solid rgba(37,42,64,.6);vertical-align:top;}
.code{background:#080a12;border:1px solid var(--border);border-radius:8px;padding:.8rem 1rem;margin:.6rem 0;font-family:'Geist Mono',monospace;font-size:.68rem;line-height:1.75;overflow-x:auto;white-space:pre-wrap;}
.code .c{color:#4a5070;}.code .k{color:var(--sky);}.code .s{color:var(--peach);}.code .n{color:var(--mint);}.code .v{color:var(--violet);}
.pill{display:inline-block;font-size:.52rem;font-weight:700;letter-spacing:.06em;text-transform:uppercase;padding:.15em .5em;border-radius:99px;margin-right:.15rem;vertical-align:middle;}
.p-fix{background:rgba(62,232,181,.08);color:var(--mint);border:1px solid rgba(62,232,181,.2);}
.p-risk{background:rgba(255,90,126,.08);color:var(--coral);border:1px solid rgba(255,90,126,.2);}
.p-warn{background:rgba(245,197,66,.08);color:var(--gold);border:1px solid rgba(245,197,66,.2);}
.callout{border-radius:8px;padding:.75rem 1rem;margin:.75rem 0;font-size:.8rem;}
.co-gold{background:rgba(245,197,66,.03);border-left:3px solid var(--gold);}
.co-mint{background:rgba(62,232,181,.03);border-left:3px solid var(--mint);}
.co-coral{background:rgba(255,90,126,.03);border-left:3px solid var(--coral);}
.co-sky{background:rgba(77,168,255,.03);border-left:3px solid var(--sky);}
.divider{height:1px;background:linear-gradient(to right,transparent,var(--border),transparent);margin:2.5rem 0;}
.scenario{background:var(--s2);border:1px solid var(--border);border-radius:10px;padding:.9rem 1.1rem;margin:.6rem 0;position:relative;}
.scenario::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;border-radius:10px 10px 0 0;}
.sc-red::before{background:var(--coral);}
.sc-yellow::before{background:var(--gold);}
.sc-green::before{background:var(--mint);}
.sc-label{font-size:.56rem;font-weight:700;text-transform:uppercase;letter-spacing:.1em;margin-bottom:.25rem;}
.sc-red .sc-label{color:var(--coral);}
.sc-yellow .sc-label{color:var(--gold);}
.sc-green .sc-label{color:var(--mint);}
.scenario p{font-size:.76rem;color:var(--dim);margin-bottom:.3rem;}
.scenario strong{color:var(--text);}
@media(max-width:768px){.grid-2,.grid-3{grid-template-columns:1fr;}.content{padding:1rem;}}
</style>
</head>
<body>

<div class="hero">
  <span class="hero-tag">Failure Prevention ¬∑ Every Way the Demo Can Break</span>
  <h1>Resilience & Pre-Flight Plan</h1>
  <p class="hero-sub">The Golden Cache and asset loading aren't risks if you engineer them correctly. This document turns "hope it works" into "it literally cannot fail during the demo."</p>
</div>

<div class="content">

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PROBLEM 1: CACHE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section">
<span class="section-tag">Problem 1</span>
<h2>The Golden Cache Is Not a Gamble ‚Äî It's a Guarantee</h2>

<p>The concern: "What if fuzzy matching picks the wrong cached response? What if a judge types something our cache doesn't cover?" These are valid ‚Äî but solvable by changing how the cache works.</p>

<h3>The Fix: Three-Tier Matching, Not Just Fuzzy</h3>

<p>Instead of relying on a single Levenshtein distance threshold (fragile), use a three-tier match strategy that gets progressively smarter:</p>

<div class="code"><span class="c">// response-resolver.ts ‚Äî The improved resolution chain</span>

async function <span class="k">resolveResponse</span>(taskId: string, input: string): Promise&lt;SceneScript&gt; {

  <span class="c">// ‚ïê‚ïê‚ïê TIER 1: Exact key match (demo script prompts) ‚ïê‚ïê‚ïê</span>
  <span class="c">// These are the prompts YOU will type during the demo.</span>
  <span class="c">// Stored as exact lowercase strings. Instant. Infallible.</span>
  const exactMatch = demoScriptCache[taskId]?.[normalize(input)];
  if (exactMatch) return exactMatch; <span class="c">// &lt;1ms, 100% reliable</span>

  <span class="c">// ‚ïê‚ïê‚ïê TIER 2: Keyword intent match (structured, not fuzzy) ‚ïê‚ïê‚ïê</span>
  <span class="c">// Instead of fuzzy string distance, extract KEYWORDS and match INTENT.</span>
  <span class="c">// "give rogue a basket" and "the rogue needs their own basket"</span>
  <span class="c">// both match intent: { actor: "rogue", action: "give", object: "basket" }</span>
  const intentMatch = matchByIntent(taskId, input);
  if (intentMatch &amp;&amp; intentMatch.confidence > <span class="n">0.7</span>) return intentMatch.response;

  <span class="c">// ‚ïê‚ïê‚ïê TIER 3: Live Claude API (with guardrails) ‚ïê‚ïê‚ïê</span>
  try {
    const live = await callClaude(taskId, input, { timeout: <span class="n">8000</span> });
    const parsed = parseAndValidate(live, taskId);
    if (parsed) return parsed;
  } catch (e) {
    <span class="c">// timeout or parse failure ‚Äî fall through</span>
  }

  <span class="c">// ‚ïê‚ïê‚ïê TIER 4: Graceful funny fallback ‚ïê‚ïê‚ïê</span>
  <span class="c">// NOT random. Pick the GENERIC funny fail for this task.</span>
  <span class="c">// Every task has a "catch-all" fail that works for ANY input.</span>
  return genericFail[taskId]; <span class="c">// &lt;1ms, always funny, always valid</span>
}</div>

<h3>Tier 1: The Demo Script Cache (Bulletproof)</h3>
<p>This is separate from the general cache. These are the <strong>exact prompts you plan to type during the demo</strong>. They're hardcoded key-value pairs. No fuzzy matching. No AI. Just a lookup table.</p>

<div class="code"><span class="c">// cache/demo-script.ts ‚Äî Hardcoded. Tested. Infallible.</span>

const demoScriptCache: Record&lt;string, Record&lt;string, SceneScript&gt;&gt; = {
  <span class="s">"adventurers-picnic"</span>: {
    <span class="c">// Demo beat 1: The vague prompt (FUNNY_FAIL)</span>
    <span class="s">"have a picnic"</span>: {
      success_level: <span class="s">"FUNNY_FAIL"</span>,
      narration: <span class="s">"The Barbarian opens the basket with an axe. There are sandwiches in the fountain now."</span>,
      stars: 1,
      actions: [
        { type: <span class="s">"animate"</span>, actor: <span class="s">"barbarian"</span>, anim: <span class="s">"Melee_TwoHand"</span> },
        { type: <span class="s">"react"</span>, effect: <span class="s">"explosion-cartoon"</span>, position: <span class="s">"center"</span> },
        { type: <span class="s">"animate"</span>, actor: <span class="s">"knight"</span>, anim: <span class="s">"Block"</span> },
        { type: <span class="s">"animate"</span>, actor: <span class="s">"archer"</span>, anim: <span class="s">"Aim_Bow"</span> },
        { type: <span class="s">"animate"</span>, actor: <span class="s">"mage"</span>, anim: <span class="s">"Sit"</span>, delay_ms: 800 },
        { type: <span class="s">"react"</span>, effect: <span class="s">"sad-cloud"</span>, position: <span class="s">"center"</span>, delay_ms: 1200 }
      ]
    },

    <span class="c">// Demo beat 2: Partial fix (PARTIAL_SUCCESS)</span>
    <span class="s">"give the rogue their own basket"</span>: { <span class="c">/* ... tested response ... */</span> },

    <span class="c">// Demo beat 3: Full solution (FULL_SUCCESS)</span>
    <span class="s">"use rocks to hold the blanket down, give the rogue their own basket, take the archers bow and give them a fishing rod, the knight pours drinks carefully without magic, and the mage only uses a tiny warming spell"</span>: { <span class="c">/* ... */</span> },
  },
  <span class="c">// ... repeat for every demo-scripted prompt across all tasks</span>
};</div>

<div class="callout co-mint">
<strong>Key insight:</strong> During the actual demo, Danielle types EXACTLY these prompts. They're rehearsed. They hit Tier 1 every time. Zero latency. Zero risk. The judges see an instant, polished response because it IS instant ‚Äî it's a lookup, not an API call. The judges don't know the difference between a cached response and a live one. They both look identical.
</div>

<h3>Tier 2: Intent Matching (Replaces Fragile Fuzzy Match)</h3>
<p>For when judges go off-script. Instead of "how similar is this string?" ask "what is this person trying to do?"</p>

<div class="code"><span class="c">// ai/intent-matcher.ts ‚Äî Keyword extraction, not string distance</span>

interface <span class="v">Intent</span> {
  actors: string[];     <span class="c">// "rogue", "knight", "barbarian"</span>
  actions: string[];    <span class="c">// "give", "fix", "stop", "help"</span>
  objects: string[];    <span class="c">// "basket", "blanket", "bow", "food"</span>
  modifiers: string[];  <span class="c">// "own", "small", "carefully", "gently"</span>
}

<span class="c">// Each cached response is tagged with its intent pattern:</span>
const intentIndex: Record&lt;string, { intent: Intent; response: SceneScript }[]&gt; = {
  <span class="s">"adventurers-picnic"</span>: [
    {
      intent: { actors: [<span class="s">"rogue"</span>], actions: [<span class="s">"give"</span>,<span class="s">"own"</span>,<span class="s">"separate"</span>], objects: [<span class="s">"basket"</span>,<span class="s">"food"</span>], modifiers: [] },
      response: { <span class="c">/* PARTIAL_SUCCESS ‚Äî rogue gets own basket */</span> }
    },
    {
      intent: { actors: [<span class="s">"archer"</span>], actions: [<span class="s">"take"</span>,<span class="s">"remove"</span>,<span class="s">"stop"</span>], objects: [<span class="s">"bow"</span>], modifiers: [] },
      response: { <span class="c">/* PARTIAL_SUCCESS ‚Äî archer disarmed */</span> }
    },
    {
      intent: { actors: [<span class="s">"barbarian"</span>], actions: [<span class="s">"hold"</span>,<span class="s">"anchor"</span>,<span class="s">"secure"</span>], objects: [<span class="s">"blanket"</span>,<span class="s">"rock"</span>], modifiers: [] },
      response: { <span class="c">/* PARTIAL_SUCCESS ‚Äî blanket secured */</span> }
    },
    <span class="c">// ... 20+ intent patterns per task</span>
  ]
};

function <span class="k">matchByIntent</span>(taskId: string, input: string): { response: SceneScript; confidence: number } | null {
  const words = normalize(input).split(<span class="s">/\s+/</span>);
  const candidates = intentIndex[taskId] || [];
  let bestMatch = null;
  let bestScore = <span class="n">0</span>;

  for (const candidate of candidates) {
    let score = <span class="n">0</span>;
    let maxPossible = <span class="n">0</span>;

    <span class="c">// Score: how many intent keywords appear in the input?</span>
    for (const actor of candidate.intent.actors) {
      maxPossible++;
      if (words.some(w => w.includes(actor) || synonyms[actor]?.some(s => w.includes(s)))) score++;
    }
    for (const action of candidate.intent.actions) {
      maxPossible++;
      if (words.some(w => w.includes(action) || synonyms[action]?.some(s => w.includes(s)))) score++;
    }
    for (const obj of candidate.intent.objects) {
      maxPossible++;
      if (words.some(w => w.includes(obj) || synonyms[obj]?.some(s => w.includes(s)))) score++;
    }

    const confidence = maxPossible > <span class="n">0</span> ? score / maxPossible : <span class="n">0</span>;
    if (confidence > bestScore) {
      bestScore = confidence;
      bestMatch = { response: candidate.response, confidence };
    }
  }

  return bestMatch;
}

<span class="c">// Synonym map so "remove the bow" matches "take away the bow"</span>
const synonyms: Record&lt;string, string[]&gt; = {
  <span class="s">"give"</span>: [<span class="s">"hand"</span>, <span class="s">"offer"</span>, <span class="s">"provide"</span>, <span class="s">"let"</span>],
  <span class="s">"take"</span>: [<span class="s">"remove"</span>, <span class="s">"grab"</span>, <span class="s">"confiscate"</span>, <span class="s">"steal"</span>],
  <span class="s">"stop"</span>: [<span class="s">"prevent"</span>, <span class="s">"dont"</span>, <span class="s">"no"</span>, <span class="s">"quit"</span>],
  <span class="s">"basket"</span>: [<span class="s">"bag"</span>, <span class="s">"box"</span>, <span class="s">"container"</span>, <span class="s">"hamper"</span>],
  <span class="s">"blanket"</span>: [<span class="s">"cloth"</span>, <span class="s">"sheet"</span>, <span class="s">"mat"</span>, <span class="s">"rug"</span>],
  <span class="s">"bow"</span>: [<span class="s">"weapon"</span>, <span class="s">"arrow"</span>, <span class="s">"arrows"</span>],
  <span class="s">"rock"</span>: [<span class="s">"stone"</span>, <span class="s">"weight"</span>, <span class="s">"heavy"</span>, <span class="s">"anchor"</span>],
  <span class="c">// ... ~50 synonym pairs per task</span>
};</div>

<div class="callout co-gold">
<strong>Why this is better than Levenshtein:</strong> "give rogue basket" and "maybe the thief should get their own bag" have a huge string distance ‚Äî Levenshtein would miss it. But intent matching catches both: actor=rogue (synonym: thief), action=give (synonym: get), object=basket (synonym: bag). Confidence: 3/3 = 1.0. Perfect match.
</div>

<h3>Tier 4: The "Catch-All" Fail (Never a Bad Response)</h3>
<p>Every task has ONE generic funny fail that works no matter what the input was. It doesn't reference the child's prompt ‚Äî it just shows the characters being chaotic in a way that's always entertaining.</p>

<div class="code"><span class="c">// For Task 7 (Picnic), the catch-all fail is:</span>
{
  success_level: <span class="s">"FUNNY_FAIL"</span>,
  narration: <span class="s">"The adventurers tried their best. The lemonade is floating again."</span>,
  stars: <span class="n">1</span>,
  actions: [
    { type: <span class="s">"animate"</span>, actor: <span class="s">"mage"</span>, anim: <span class="s">"MagicCast"</span> },
    { type: <span class="s">"react"</span>, effect: <span class="s">"sparkle-magic"</span>, position: <span class="s">"center"</span> },
    { type: <span class="s">"animate"</span>, actor: <span class="s">"barbarian"</span>, anim: <span class="s">"GetHit"</span>, delay_ms: <span class="n">400</span> },
    { type: <span class="s">"react"</span>, effect: <span class="s">"question-marks"</span>, position: <span class="s">"right"</span>, delay_ms: <span class="n">600</span> },
    { type: <span class="s">"animate"</span>, actor: <span class="s">"rogue"</span>, anim: <span class="s">"Sneak"</span>, delay_ms: <span class="n">800</span> }
  ]
}
<span class="c">// This ALWAYS works. It doesn't need to match the input.</span>
<span class="c">// It just shows characters being funny while the narration</span>
<span class="c">// gently tells the kid to try again with more detail.</span></div>
</div>

<div class="divider"></div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PROBLEM 2: ASSET LOADING ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section">
<span class="section-tag">Problem 2</span>
<h2>Asset Loading ‚Äî Eliminate the Loading Spinner</h2>

<p>The concern: switching tasks triggers a loading pause. On slow wifi at a demo venue, this could be 5‚Äì10 seconds of dead air. Here's how to make it instant.</p>

<h3>Strategy: Preload EVERYTHING on App Start</h3>
<p>Don't lazy-load per task. Load the entire asset library on app startup behind a branded splash screen. The total payload is manageable.</p>

<h3>Step 1: Measure the Actual Payload</h3>
<table>
<tr><th>Asset Type</th><th>Estimated Size (GLB)</th><th>Notes</th></tr>
<tr><td>Characters (7 core: 5 Adventurers + Skeleton + 1 bonus)</td><td>~3‚Äì5 MB</td><td>Low-poly, ~1000‚Äì5000 tris each, single 1024 texture</td></tr>
<tr><td>Animation Pack (161 clips)</td><td>~2‚Äì4 MB</td><td>Skeletal keyframes, no geometry duplication</td></tr>
<tr><td>Environment models (all 7 task stages)</td><td>~8‚Äì15 MB</td><td>Modular pieces, shared texture atlas</td></tr>
<tr><td>Props (food, tools, furniture, decorations)</td><td>~3‚Äì6 MB</td><td>Tiny models, often &lt;200 tris each</td></tr>
<tr><td>Audio (SFX, subset of Kenney packs)</td><td>~2‚Äì3 MB</td><td>Only load SFX actually used, .ogg format</td></tr>
<tr><td>Lottie JSONs (12 reactions)</td><td>~0.5 MB</td><td>Tiny vector animations</td></tr>
<tr><th>Total Initial Load</th><th>~20‚Äì35 MB</th><th>Comparable to a single high-res image</th></tr>
</table>

<div class="callout co-mint">
<strong>20‚Äì35 MB is nothing.</strong> A typical web page loads 3‚Äì5 MB. A YouTube video buffers 50 MB in seconds. Even on mediocre wifi (10 Mbps), 35 MB loads in under 30 seconds. On good wifi, under 5 seconds. And you can make it FEEL instant with the approach below.
</div>

<h3>Step 2: The Branded Loading Experience</h3>
<div class="code"><span class="c">// ui/SplashScreen.tsx ‚Äî Shows while assets preload</span>

function <span class="v">SplashScreen</span>({ progress }: { progress: number }) {
  return (
    &lt;div className=<span class="s">"splash"</span>&gt;
      &lt;h1&gt;‚ú® Prompt Quest ‚ú®&lt;/h1&gt;
      &lt;p&gt;<span class="s">"Loading your adventure..."</span>&lt;/p&gt;

      <span class="c">{/* Animated progress bar with fun messages */}</span>
      &lt;ProgressBar value={progress} /&gt;
      &lt;p className=<span class="s">"loading-message"</span>&gt;
        {progress &lt; <span class="n">20</span> &amp;&amp; <span class="s">"üó°Ô∏è Sharpening the Knight's sword..."</span>}
        {progress &gt;= <span class="n">20</span> &amp;&amp; progress &lt; <span class="n">40</span> &amp;&amp; <span class="s">"üíÄ Reassembling the Skeleton..."</span>}
        {progress &gt;= <span class="n">40</span> &amp;&amp; progress &lt; <span class="n">60</span> &amp;&amp; <span class="s">"üßô The Mage is trying NOT to use magic..."</span>}
        {progress &gt;= <span class="n">60</span> &amp;&amp; progress &lt; <span class="n">80</span> &amp;&amp; <span class="s">"üß∫ Packing the picnic basket..."</span>}
        {progress &gt;= <span class="n">80</span> &amp;&amp; <span class="s">"üéâ Almost ready for adventure!"</span>}
      &lt;/p&gt;
    &lt;/div&gt;
  );
}</div>

<h3>Step 3: Progressive Preloading (Smart Order)</h3>
<div class="code"><span class="c">// core/AssetPreloader.ts ‚Äî Load everything, in the right order</span>

async function <span class="k">preloadAll</span>(onProgress: (pct: number) => void) {
  const totalSteps = <span class="n">4</span>;
  let completed = <span class="n">0</span>;

  <span class="c">// PHASE 1: Load the DEMO task first (T7 Picnic = what you show first)</span>
  await preloadTask(<span class="s">"adventurers-picnic"</span>);
  completed++;
  onProgress(completed / totalSteps * <span class="n">100</span>);
  <span class="c">// ‚Üí At this point the demo can START even if other tasks aren't ready</span>

  <span class="c">// PHASE 2: Load shared resources (animations, common characters)</span>
  await Promise.all([
    loadGLB(<span class="s">"assets/animations/character-animations.glb"</span>),
    loadGLB(<span class="s">"assets/characters/knight.glb"</span>),
    loadGLB(<span class="s">"assets/characters/barbarian.glb"</span>),
    loadGLB(<span class="s">"assets/characters/mage.glb"</span>),
    loadGLB(<span class="s">"assets/characters/archer.glb"</span>),
    loadGLB(<span class="s">"assets/characters/rogue.glb"</span>),
    loadGLB(<span class="s">"assets/characters/skeleton.glb"</span>),
  ]);
  completed++;
  onProgress(completed / totalSteps * <span class="n">100</span>);

  <span class="c">// PHASE 3: Load the second demo task (T2 Knight in Space)</span>
  await preloadTask(<span class="s">"knight-space-mission"</span>);
  completed++;
  onProgress(completed / totalSteps * <span class="n">100</span>);

  <span class="c">// PHASE 4: Background-load all remaining tasks</span>
  await Promise.all([
    preloadTask(<span class="s">"skeleton-birthday"</span>),
    preloadTask(<span class="s">"mage-kitchen"</span>),
    preloadTask(<span class="s">"barbarian-school"</span>),
    preloadTask(<span class="s">"dungeon-concert"</span>),
    preloadTask(<span class="s">"skeleton-pizza"</span>),
  ]);
  completed++;
  onProgress(<span class="n">100</span>);

  <span class="c">// Everything cached in memory. Task switching is now instant.</span>
}</div>

<div class="callout co-gold">
<strong>The key trick:</strong> After Phase 1 completes (just the Picnic task, maybe 5‚Äì8 MB), you can dismiss the splash screen and START the demo. The other tasks keep loading in the background while you're demoing Task 7. By the time you switch to Task 2 (2+ minutes into the demo), it's already loaded.
</div>

<h3>Step 4: GLB Optimization (Shrink the Payload)</h3>
<table>
<tr><th>Optimization</th><th>How</th><th>Size Reduction</th></tr>
<tr><td>Use GLB not GLTF</td><td>GLB is binary (single file). GLTF is JSON + separate .bin + textures.</td><td>~20% smaller</td></tr>
<tr><td>Draco compression</td><td><code>gltf-transform optimize --compress draco</code></td><td>~60‚Äì80% geometry reduction</td></tr>
<tr><td>Texture compression</td><td>Downscale atlases to 512√ó512 (still looks fine for low-poly)</td><td>~75% texture reduction</td></tr>
<tr><td>Only ship what's used</td><td>Don't include every model from every pack. Curate per-task.</td><td>~50% fewer files</td></tr>
<tr><td>gzip on Vercel</td><td>Vercel auto-gzips static assets. GLB compresses well.</td><td>~30‚Äì40% transfer reduction</td></tr>
</table>

<p>After optimization, the total payload should be <strong>10‚Äì15 MB</strong>. On any reasonable connection, the splash screen shows for 2‚Äì5 seconds, then the demo is fully loaded with zero subsequent loading.</p>

<h3>Step 5: Offline-First Fallback</h3>
<div class="code"><span class="c">// If you're worried about venue wifi, add a Service Worker</span>

<span class="c">// vite.config.ts ‚Äî VitePWA plugin creates a service worker that</span>
<span class="c">// pre-caches ALL assets on first visit. After that, the game</span>
<span class="c">// works completely offline (cached responses + cached assets).</span>

import { VitePWA } from <span class="s">'vite-plugin-pwa'</span>;

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: <span class="s">'autoUpdate'</span>,
      workbox: {
        globPatterns: [<span class="s">'**/*.{js,css,html,glb,json,ogg,mp3}'</span>],
        maximumFileSizeToCacheInBytes: <span class="n">50 * 1024 * 1024</span>, <span class="c">// 50MB</span>
      }
    })
  ]
});

<span class="c">// PRE-DEMO ROUTINE:</span>
<span class="c">// 1. Open the game on the demo laptop the night before</span>
<span class="c">// 2. Let it fully load once (service worker caches everything)</span>
<span class="c">// 3. At the demo, game loads from local cache ‚Äî zero network needed</span>
<span class="c">// 4. Even Claude API responses come from Golden Cache ‚Äî zero network</span>
<span class="c">// 5. The entire demo can run on AIRPLANE MODE</span></div>

<div class="callout co-coral">
<strong>Nuclear option: the demo can run on airplane mode.</strong> Service Worker caches all assets. Golden Cache serves all demo prompts. TTS is browser-native (no network). The only thing that needs network is live Claude API calls for judge off-script prompts ‚Äî and those fall back to the cached generic funny fail. You literally cannot be killed by wifi issues.
</div>
</div>

<div class="divider"></div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PRE-FLIGHT CHECKLIST ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section">
<span class="section-tag">Pre-Flight</span>
<h2>Demo Day Pre-Flight Checklist</h2>

<p>Run this the night before AND the morning of the demo. Drew runs the technical checks, Danielle runs the content checks.</p>

<div class="code"><span class="c">// .claude/commands/pre-demo.md ‚Äî Run with /pre-demo</span>

<span class="k">## Technical Pre-Flight (Drew)</span>

‚ñ° Vercel deployment is live and serving latest build
‚ñ° Open game on demo laptop ‚Äî let it fully load (populates Service Worker cache)
‚ñ° Disconnect wifi ‚Üí reload ‚Üí confirm game still works (offline mode)
‚ñ° Reconnect wifi ‚Üí confirm Claude API responds (&lt;5 sec)
‚ñ° Check: All 7 tasks load without errors in console
‚ñ° Check: Every demo-script prompt returns the exact expected response
‚ñ° Check: Switching between tasks has zero loading delay
‚ñ° Check: Voice input works in Chrome (say "have a picnic")
‚ñ° Check: TTS reads narrations clearly
‚ñ° Check: Lottie reactions fire and position correctly
‚ñ° Check: Sound effects play (not muted, volume reasonable)
‚ñ° Check: Stars/badges persist across task switches
‚ñ° Charge laptop to 100%
‚ñ° Bring charger as backup
‚ñ° Know the venue wifi password (backup for API)
‚ñ° Have mobile hotspot as backup backup

<span class="k">## Content Pre-Flight (Danielle)</span>

‚ñ° Demo script printed on paper (don't rely on memory)
‚ñ° Exact prompts to type for each demo beat memorized
‚ñ° Know which task to show FIRST (T7 Picnic)
‚ñ° Know which task to show SECOND (T2 Knight in Space)
‚ñ° Practiced the "vague prompt ‚Üí specific prompt ‚Üí detailed prompt" arc
‚ñ° Tested the funniest funny fails ‚Äî confirmed they land
‚ñ° Tested the best full success ‚Äî confirmed confetti/celebration fires
‚ñ° Submission description written and reviewed
‚ñ° Video recording ready if needed
‚ñ° Know the "why this wins" pitch: Opus 4.6 as core mechanic,
  educational impact, production quality, novel architecture</div>
</div>

<div class="divider"></div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê FAILURE SCENARIOS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section">
<span class="section-tag">Scenarios</span>
<h2>Every Way the Demo Can Fail ‚Äî And What Happens</h2>

<div class="scenario sc-red">
<div class="sc-label">üî¥ Scenario: Venue wifi is down completely</div>
<p><strong>What happens:</strong> Service Worker serves all assets from local cache. Golden Cache serves all demo-script prompts. TTS is browser-native. Game works perfectly.</p>
<p><strong>What you lose:</strong> Live Claude API for judge off-script prompts. Those fall back to the generic funny fail cache entry.</p>
<p><strong>Judge perception:</strong> They see a game that works flawlessly. They have no way to know it's running offline.</p>
</div>

<div class="scenario sc-red">
<div class="sc-label">üî¥ Scenario: Claude API is down globally</div>
<p><strong>What happens:</strong> Identical to above. Every demo-scripted prompt is cached. Off-script prompts get funny fallbacks.</p>
<p><strong>What you lose:</strong> Live responses for novel prompts.</p>
<p><strong>Judge perception:</strong> Indistinguishable from a working API. Cached responses ARE Claude responses ‚Äî they were generated by Opus 4.6, just pre-computed.</p>
</div>

<div class="scenario sc-yellow">
<div class="sc-label">üü° Scenario: Judge types something completely unexpected</div>
<p><strong>Example:</strong> "make the skeleton dab and do a backflip while eating spaghetti"</p>
<p><strong>What happens:</strong> Tier 1 (exact match): miss. Tier 2 (intent match): partial match on "skeleton" + "eat" ‚Üí returns a skeleton eating scene. If confidence too low, goes to Tier 3 (live Claude). If Claude times out, Tier 4 returns the generic funny fail.</p>
<p><strong>Judge perception:</strong> Either they get a surprisingly good intent-matched response, or they get a funny fail that makes them laugh. Both are wins. The narration says something like "The adventurers tried their best. The lemonade is floating again." ‚Äî it's charming.</p>
</div>

<div class="scenario sc-yellow">
<div class="sc-label">üü° Scenario: A GLB file is corrupted or missing</div>
<p><strong>What happens:</strong> AssetLoader catches the error. The SceneScriptPlayer skips any action referencing that asset. Other actions still play. Console logs the error.</p>
<p><strong>What you lose:</strong> One character or prop is invisible in the scene.</p>
<p><strong>Prevention:</strong> The pre-flight checklist verifies all 7 tasks load without console errors. Catch this the night before, not during the demo.</p>
</div>

<div class="scenario sc-yellow">
<div class="sc-label">üü° Scenario: Claude returns malformed JSON</div>
<p><strong>What happens:</strong> parseAndValidate() tries JSON.parse first. If that fails, regex extracts JSON from markdown code blocks (Claude sometimes wraps in ```json). If that fails, falls through to Tier 4 generic fail.</p>
<p><strong>Prevention:</strong> System prompt ends with "RESPOND WITH ONLY A JSON OBJECT. NO OTHER TEXT." Tested with 20+ inputs per task. Malformation rate with Opus 4.6 is &lt;2%.</p>
</div>

<div class="scenario sc-yellow">
<div class="sc-label">üü° Scenario: Intent matcher picks wrong cached response</div>
<p><strong>Example:</strong> Kid says "the mage should cook" in the Picnic task. Intent matcher picks a response about the Mage Kitchen task (wrong task).</p>
<p><strong>Prevention:</strong> Intent matching is scoped per-task. It only searches the intent index for the CURRENT task. Cross-task contamination is impossible.</p>
</div>

<div class="scenario sc-green">
<div class="sc-label">üü¢ Scenario: Everything works perfectly</div>
<p><strong>What happens:</strong> Demo-scripted prompts hit Tier 1 cache instantly. Judge off-script prompts either hit Tier 2 intent match or Tier 3 live Claude. All assets preloaded. All scenes play smoothly. Every funny fail gets a laugh. Full success gets applause.</p>
<p><strong>This is the expected case.</strong> The architecture is designed so that the green scenario is the overwhelmingly likely outcome.</p>
</div>
</div>

<div class="divider"></div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê IMPLEMENTATION PRIORITY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section">
<span class="section-tag">Priority Order</span>
<h2>What to Build First for Maximum Resilience</h2>

<div class="callout co-sky">
<strong>The order matters.</strong> Build the resilience layers BEFORE the features. A game with 3 tasks and bulletproof caching beats a game with 7 tasks that crashes during the demo.
</div>

<table>
<tr><th>Priority</th><th>What</th><th>Why</th><th>Day</th></tr>
<tr><td><span class="pill p-risk">P0</span></td><td>Demo Script Cache (hardcoded exact responses)</td><td>Makes the demo infallible for scripted moments</td><td>Day 3</td></tr>
<tr><td><span class="pill p-risk">P0</span></td><td>Asset preloading with splash screen</td><td>Eliminates loading delays during demo</td><td>Day 2</td></tr>
<tr><td><span class="pill p-risk">P0</span></td><td>SceneScriptPlayer with error tolerance</td><td>Unknown actors/anims = skip, never crash</td><td>Day 2</td></tr>
<tr><td><span class="pill p-warn">P1</span></td><td>Intent matching (Tier 2)</td><td>Handles judge off-script prompts intelligently</td><td>Day 3</td></tr>
<tr><td><span class="pill p-warn">P1</span></td><td>Generic funny fail per task (Tier 4)</td><td>Catch-all that ALWAYS works</td><td>Day 3</td></tr>
<tr><td><span class="pill p-warn">P1</span></td><td>JSON parsing with regex fallback</td><td>Handles Claude markdown wrapping</td><td>Day 3</td></tr>
<tr><td><span class="pill p-warn">P1</span></td><td>Service Worker for offline mode</td><td>Demo survives zero wifi</td><td>Day 5</td></tr>
<tr><td><span class="pill p-fix">P2</span></td><td>GLB Draco compression</td><td>Smaller payload = faster load</td><td>Day 5</td></tr>
<tr><td><span class="pill p-fix">P2</span></td><td>Full intent index (20+ patterns per task)</td><td>Higher cache hit rate for novel prompts</td><td>Day 4</td></tr>
<tr><td><span class="pill p-fix">P2</span></td><td>Pre-flight checklist automation</td><td>Catches problems before demo</td><td>Day 6</td></tr>
</table>
</div>

<div class="divider"></div>

<p style="text-align:center;margin:2rem 0;color:var(--dim);font-size:.68rem;">
Prompt Quest ¬∑ Resilience & Pre-Flight Plan ¬∑ Feb 2026<br>
"It literally cannot fail during the demo."
</p>

</div>
</body>
</html>
